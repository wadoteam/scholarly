<!DOCTYPE html>
<!-- saved from url=(0031)http://scholarly.vernacular.io/ -->
<html lang="en-GB" xmlns="http://www.w3.org/1999/html">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <meta name="viewport" content="width=device-width">
    <title>Scholarly HTML — Markedly Smart</title>
    <link rel="stylesheet" href="./ScholaryAssets/styles/scholarly.css">
    <link rel="stylesheet" href="./ScholaryAssets/styles/prism-coy.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
</head>
<body prefix="schema: http://schema.org/ xsd: http://www.w3.org/2001/XMLSchema# sa: https://ns.science.ai/">
<a id="page-up" class="fa fa-angle-double-up fa-2x " href="#table-of-content"></a>
<header>
    <p class="title">WADO Project</p>
    <p class="subtitle">Wade</p>
</header>
<article id="what" typeof="schema:ScholarlyArticle" resource="#">
    <h1>An ontology for web development concepts</h1>
    <section>
        <ol>
            <li property="schema:author" typeof="sa:ContributorRole">
                <a property="schema:author" href=# typeof="schema:Person">
                    <span property="schema:givenName">Alexandru</span>
                    <span property="schema:familyName">Furculita</span>
                </a>
            </li>
            </br>
            <li property="schema:contributor" typeof="sa:ContributorRole">
                <a property="schema:contributor" href="#" typeof="schema:Person">
                    <span property="schema:givenName">Andrei</span>
                    <span property="schema:familyName">Juravle</span>
                </a>
            </li>
            </br>
            <li property="schema:contributor" typeof="sa:ContributorRole">
                <a property="schema:contributor" href="#" typeof="schema:Person">
                    <span property="schema:givenName">Madalina</span>
                    <span property="schema:familyName">Neghina</span>
                </a>
            </li>
            </br>
            <li property="schema:contributor" typeof="sa:ContributorRole">
                <a property="schema:contributor" href="#" typeof="schema:Person">
                    <span property="schema:givenName">Constantin</span>
                    <span property="schema:familyName">Serediuc</span>
                </a>
            </li>
        </ol>
    </section>

    <section typeof="sa:Abstract" id="abstract">
        <h1>Abstract</h1>
        <p>
            Wado project aims to construct and manage an ontology with information about web development. Informations
            which will be included in ontology varies from programming languages and IDEs to specific algorithms and
            arhitecture
            patterns. The design of ontology aims a modular approach, such that new knowledge in different formats can
            easily extend
            it. Also, project includes a interface which allows a user to search information about web development using
            natural language.
            The main architectural propose is to link information from different sources and to infer new data from that
            information.
        </p>
    </section>


    <section id="table-of-content">
        <h1>Table of content</h1>
        <p>
        <ul class="no-decoration">
            <li><a href="#introduction">1. Introduction</a></li>
            <li><a href="#objective">2. Objectives</a></li>
            <li><a href="#architecture">3. Architecture</a></li>
            <li><a href="#architecture-ontology">3.1. Ontology Architecture</a></li>
            <li><a href="#data-sources-github">3.2. Github GraphQL</a></li>
            <li><a href="#data-sources-wikidata">3.3. WikiData</a></li>
            <li><a href="#interogation">3.4. Natural language like Input</a></li>
            <li><a href="#schema">3.5. Ontology schema</a></li>
            <li><a href="#development">4. Development</a></li>
            <li><a href="#development-build-ontology">4.1. Build Ontology Microservice</a></li>
            <li><a href="#development-query-ontology">4.2. Querying Ontology Microservice</a></li>
            <li><a href="#development-process-input">4.3. Process Input Microservice</a></li>
            <li><a href="#conclusion">5. Conclusion</a></li>
            <li><a href="#biblio">6. Bibliography</a></li>
        </ul>
        </p>
    </section>

    <section id="introduction">
        <h1>1. Introduction</h1>
        <p>Web semantics represents a new step in the evolution of web and the use of the huge amount of information
            from World Wide Web. Ontologies with help from reasoners can retain information and the semantic links
            between them.
            A lot of domains are represented under a ontology which grow in time and offers new ways of understanding a
            domain and
            its links with others. Computer science is definitely a domain which deserve a comprehensive ontology.
        </p>
    </section>

    <section id="objective">
        <h1>2. Objectives</h1>
        <p>
            In order to create an ontology which retain semantic data about computer science domains a few points must
            be take in consideration:
        <ul>
            <li>
                what is the ideal architectural design for creation of a maintainable, rich in information and easy to
                extend ontology
            </li>
            <li>
                which concepts must a such
                ontology retain through its classes, properties and instances? Which datasources can be used to create a
                such ontology
            </li>
            <li>
                how can it take advantage of reasoner inference to find new links between information especially between
                data
                come from different sources and diferent formats
            </li>
            <li>
                which datasource can be used to create a such
                ontology
            </li>

            <li>
                how can a user retrive information from a such ontology in the easiest way
            </li>
        </ul>

        </p>
    </section>

    <section id="architecture">
        <h1>3. Arhitecture</h1>
        <p>
            The architecture of ontology must allow different data sources(like a REST api, a GraphQl Api, an existing
            ontology) with different formats(like json, turtle etc.). To achieve modularity it will be used
            a set of design patterns specific for ontologies. Also, not only ontology must be modular, but entire
            project as well. Because of this, a microservice architectural approach will be used. (diagrama cu
            arhitectura/ module)
        </p>
    </section>

    <section id="architecture-ontology">
        <h2>3.1 Ontology's architecture</h2>
        <p>
            Ontology will aggregate different data sources. Primary sources are json responses from GraphQl
            Github Api
            <a target="_blank" href="https://developer.github.com/v4/">
                <strong>GraphQl Github Api</strong>
            </a>
            and <a target="_blank" href="https://www.wikidata.org/wiki/Wikidata:Main_Page"><strong>WikiData
            ontology.</strong></a>
            The data from this sources will be linked under WADO ontology classes. To assure correctness and modular
            design
            it will be used <a target="_blank" href="http://ontologydesignpatterns.org/wiki/Submissions:AlignmentODPs">Aligment
            Ontology
            Design Patterns</a>
            <aside typeof="schema:WPSideBar"><i class="fa fa-info-circle" aria-hidden="true"></i>
                OntologyDesignPatterns is a project from Association for Ontology Design & Patterns which propose is to
                create a portal where web semantic community can share, discuss and certified design patterns specific
                for
                good and reusable ontologies.
            </aside>
        </p>
        <p>
            Aligment of data sources under Wado ontology is made following <strong>Composition over Equivalence
            Principle.</strong>
            The problem of modular ontology design is that the number of subconcept is not know
            and the name of concept as well.The common approach is making classes which representing a new concept,
            equivalent but, when the number of classes grow is difficult to add new class( this means to modify existing
            classes to
            be equivalent with new class). Because of this, composition over equivalence is choose to bo main principle
            for linking
            data. So, classes of WADO ontology will be defined to represent different representation of same concept.
            For
            exemple
            WADO class <code>wado:language</code> will have <code>wd:Q9143(ProgrammingLanguage)</code> subclass and
            another one
            which repesent <code>github language concept</code> which will be created after a graphQL query. The client
            will work
            only with WADO classes so different datasources search will be a transparent process.
            Also will be used properties from <a href="#schema">FOAF and RDFs</a> to represent relation between classes
            from different ontologies
            and discover new relation from merging classes with same URI.

            <figure typeof="sa:Image">
                <img src="././ScholaryAssets/img/normalization_aligment.jpg" width="1" height="200">
                <figcaption>
                    Fig 1.1 Exemple of aligment data through composition.
                </figcaption>
            </figure>
        </p>

        <p>
            Another alignment design pattern which will be used is <a
                href="http://ontologydesignpatterns.org/wiki/Submissions:Normalization" target="_blank">
            Normalization ODP.</a> Following this principle will be defined some axes of ontology (layers) -- de
            completat cu axele--. Every layer will have only one parent class. The relations between layers will be
            defined using restrictions not inheritance because this way layers can be independent. Also using
            restriction to establish relations between classes and not using inheritance increase level of inference and
            pass the maintenance to the reasoner.For exemple, in order to define relation between
            <code>wado:Paradigm</code> and <code>wado:FunctionalParadigm</code> and
            <code>wado:ObjectOrientedParadigm</code> it will be used a universal restriction

            <figure typeof="schema:SoftwareSourceCode">
                <meta property="schema:name" content="html">
                <pre property="schema:programmingLanguage" typeof="schema:Language" class=" language-html"><code
                        class=" language-html">
                    Paradigm has <strong>only</strong> Functional or ObjectOriented or RuleBased
                </code></pre>
                <figcaption>
                    An example of using restriction to define relations between classes
                </figcaption>
            </figure>
        </p>
    </section>

    <section id="data-sources-github">
        <h2>3.2 Ontology's data sources. GithubGraphQL</h2>
        <p>
            One of the most important data source for WADO ontology is information from github obtained through GraphQL
            Api v4.
            <aside typeof="schema:WPSideBar"><i class="fa fa-info-circle" aria-hidden="true"></i>
                The GitHub GraphQL API v4 represents an architectural and conceptual shift from the GitHub REST API v3.
                GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing
                data.<br>
                «<a target="_blank" href="http://graphql.org/">GraphQL</a> provides a complete and understandable
                description of the data in your API, gives clients
                the
                power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time,
                and
                enables powerful developer tools.»</cite>
            </aside>
            In <a href="#development">section dedicated to development</a> is defied a two steps process: creation of
            the
            ontology and interrogation. In creation step a module will populate ontology with instances with
            correspondence in Github GraphQL Api. The main types from github api which will be used in ontology are:
        <ul>
            <li>Organization</li>
            <li>Repository</li>
            <li>Pull Requests</li>
            <li>Tags</li>
            <li>Language</li>
            <li>Topic</li>
            <li>License</li>
        </ul>
        </p>
    </section>

    <section id="data-sources-wikidata">
        <h2>3.3 Ontology's data sources. Wikidata</h2>
        <p>
            Second source of information for construction of ontology is a part of another ontology: Wikidata.
            <aside typeof="schema:WPSideBar"><i class="fa fa-info-circle" aria-hidden="true"></i>
                «<a target="_blank" href="https://www.wikidata.org/wiki/Wikidata:Main_Page">Wikidata</a> is a free and
                open knowledge base that can be read and edited by both humans and machines.
                Wikidata acts as central storage for the structured data of its Wikimedia sister projects including
                Wikipedia, Wikivoyage, Wikisource, and others»</cite>
            </aside>

        </p>
    </section>
    <section id="interogation">
        <h1>3.4 Natural language ontology interogation</h1>
        <p>
            A well formed ontology is so powerfull as the tools to extract data from it, because a big ontology need
            easy and fast
            ways to retrieve desired data, mechanisms for suggestions and simple navigation through a such big amount on
            information.
            Also, is important that not only a domain expert knowing how to fetch data from an ontology but every person
            who need information
            for work, a project or for satisfying curiosity. Because of this, a natural language approach can be the
            right tool to
            retrieve data, easy and accessible for a big diversity of clients. WADO give the possibility to navigate
            through ontology data
            using natural language, offering also a system of autocomplete and suggestions. Because this approach is a
            consuming one
            from a processing time point of view, WADO use a cache system and optimizate library for autocomplete like:
            <a target="_blank"
               href="http://documentcloud.github.io/visualsearch/">VisualSearch.js</a>
        </p>
    </section>

    <section id="schema">
        <h1>3.5 Ontology schema</h1>
        <p>
            <strong>Vocabularies:</strong>
        <ul>
            <li><a target="_blank" href="http://www.w3.org/2000/01/rdf-schema#">RDFs</a> to represent taxonomy relations
            </li>
            <li><a target="_blank" href="http://xmlns.com/foaf/0.1/">FOAF</a> is used to represent relation between
                concepts and also between people. In this way
                ontology can suggest related data about a cliend's search
            </li>
            <li><a target="_blank" href="http://www.w3.org/2002/07/owl#">OWL</a> is used to represent complex relation
                between
                concepts. Also define restriction to help a reasoner infer more data.
            </li>
            <li><a target="_blank" href="https://wadoteam.github.io/ontologyVisualization/">WADO</a> is used to
                represent specific
                relations
                between WADO ontology classes: <code>wado:hasParadigm</code>, <code>wado:isPartOfOntology</code> etc.
            </li>
        </ul>

        Also, to ensure consistency and correctness of data from ontology, will be used a tool for defining constraints.
        <a target="_blank" href="https://www.w3.org/TR/shacl/">SHACL</a> is a recomandation from W3 and a powerful tool
        to write constraints.
        </p>
    </section>

    <section id="development">
        <h1>4. Development</h1>
        <p>
            To achieve all objectives WADO project development can be split in two parts:
        <ul>
            <li>ontology creation</li>
            <li>ontology interogation</li>
        </ul>
        </p>
        <p>
            Not only ontology must be modular to obtain independence and modularity but whole project too. Because of
            this
            WADO use a microservices design and define a set of independent modules, independent of each other,
            specialized
            on a certain task. Entire project is construct on the follow microservices:
        <ol>
            <li>
                <a target="_blank" href="https://github.com/wadoteam/wadoteam.github.io/issues/2">BuildOntology Micro
                    Service</a>
            </li>
            <li>
                <a target="_blank" href="https://github.com/wadoteam/wadoteam.github.io/issues/3">QueryingOntology Micro
                    Service</a>
            </li>
            <li>
                <a target="_blank" href="https://github.com/wadoteam/wadoteam.github.io/issues/4">ProcessInput Micro
                    Service</a>
            </li>
        </ol>

        All micro services mentioned will be use to create aplication by the <a target="_blank"
                                                                                href="https://github.com/wadoteam/wadoteam.github.io/issues/1">Client
        Aplication </a>module.
        </p>


        2 steps of project ( create ontology si interogarea ei)
        impartirea in microservicii independente si specializate (imagini plus explicat un pic). folosirea unui reasoner
        pentru a obtine date noi. comunicarea rest intre microservicii. tooluri: protege, jena, angular and

    </section>

    <section id="development-build-ontology">
        <h2>4.1 BuildOntology Micro service</h2>
        <p>
            This microservice cover up the first part of project development, ontology creation.
        <ul class="no-decoration">
            <li><strong>Scope:</strong> aggragate information from sources independent of formats or types and convert
                in Wado classes/predicates
            </li>
            <li><strong>Input:</strong> github graphQL api / wikidata</li>
            <li><strong>Output:</strong> wado classes/predicates</li>
        </ul>
        <figure typeof="sa:Image">
            <img src="././ScholaryAssets/img/build_ontology_microservice_diagram.jpg" width="1" height="200">
            <figcaption>
                Fig 1.2 Build Ontology Miroservice Arhitecture
            </figcaption>
        </figure>
        </p>
    </section>

    <section id="development-query-ontology">
        <h2>4.2 QueryOntology Micro service</h2>
        <p>
            This microservice is the principal node between a clien request and Wado Ontology.
        <ul class="no-decoration">
            <li><strong>Scope:</strong> query ontology based on request (filters, paginating, suggestion)</li>
            <li><strong>Input:</strong> a input procesed by the InputProcessing microservice</li>
            <li><strong>Output:</strong> a JSON Response based on the search through ontology</li>
        </ul>
        <figure typeof="sa:Image">
            <img src="././ScholaryAssets/img/query_ontology_microservice_diagram.jpg" width="1" height="200">
            <figcaption>
                Fig 1.3 Query Ontology Miroservice Arhitecture
            </figcaption>
        </figure>
        </p>
    </section>

    <section id="development-process-input">
        <h2>4.3 ProcessInput Micro service</h2>
        <p>
            This microservice is basicaly a convertor between client request and QueryOntology Microservice.
        <ul class="no-decoration">
            <li><strong>Scope:</strong> transform natural language like input into a format machine accessible</li>
            <li><strong>Input:</strong> a client natural language like input</li>
            <li><strong>Output:</strong> a REST url which translate client input in a QueryOntology Microservice input
            </li>
        </ul>
        <figure typeof="sa:Image">
            <img src="././ScholaryAssets/img/process_input_microservice_diagram.jpg" width="1" height="200">
            <figcaption>
                Fig 1.4 Query Ontology Miroservice Arhitecture
            </figcaption>
        </figure>
        </p>
    </section>


    <section id="conclusion">
        <h1>5. Conclusion</h1>
        <p>
            In conclusion, a ontology with a powerful impact in computer science development must adopt a architecture
            based on design patterns to remain open to extension, easy to maintain and debug. Also is important to catch
            important aspects of the domain and the relations between them, and defined classes as restriction of good
            implemented properties to offer the possibility of a qualitative and quantitative infered data which, at its
            turn to
            be interrogated easily in a natural language manner.
        </p>
    </section>
    <section id="biblio">
        <h1>6. Bibliography</h1>
		<ol>
			<li>
				<a href="https://www.wikidata.org/wiki/Wikidata:Main_Page">
				Wikidata
				</a>
			</li>
			<li>
				<a href="http://graphql.org/learn/">
				GraphQL
				</a>
			</li>
			<li>
				<a href="http://ontologydesignpatterns.org/wiki/Main_Page">
				Ontology Design Patterns
				</a>
			</li>
			<li>
				<a href="http://mowl-power.cs.man.ac.uk/protegeowltutorial/resources/ProtegeOWLTutorialP4_v1_3.pdf">
				Protege OWL Tutorial
				</a>
			</li>
			<li>
				<a href="http://vowl.visualdataweb.org/webvowl.html">
				WebVOWL: Web-based Visualization of Ontologies
				</a>
			</li>
			<li>
				<a href="https://www.w3.org/TR/shacl/">
				Shapes Constraint Language (SHACL)
				</a>
			</li>
		</ol>
    </section>
</article>
</body>
</html>